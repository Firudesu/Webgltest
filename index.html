<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3rd-Person Social Hub Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #87CEEB;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            cursor: none;
        }
        canvas {
            display: block;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-size: 18px;
        }
        #interaction {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-size: 16px;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 5px;
            display: none;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-size: 14px;
        }
        #chatBubble {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 200px;
            display: none;
            z-index: 200;
            pointer-events: none;
        }
        #lpkPanel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 150;
            min-width: 250px;
        }
        #lpkPanel h3 {
            margin: 0 0 10px 0;
            color: #4a90e2;
        }
        #lpkPanel button {
            background: #4a90e2;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px 0;
            width: 100%;
        }
        #lpkPanel button:hover {
            background: #357abd;
        }
        #lpkPanel button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        #fileInput {
            margin: 10px 0;
            color: white;
        }
        #lpkStatus {
            font-size: 12px;
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
        }
        .status-success { background: rgba(40, 167, 69, 0.3); }
        .status-error { background: rgba(220, 53, 69, 0.3); }
        .status-info { background: rgba(23, 162, 184, 0.3); }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">Loading Social Hub...</div>
    <div id="hud">
        <div>Player: <span id="playerName">Visitor</span></div>
        <div>Coins: <span id="coins">0</span></div>
        <div>Activity: <span id="activity">Walking</span></div>
    </div>
    <div id="interaction">
        Press E to interact
    </div>
    <div id="instructions">
        WASD: Move | Space: Jump | Shift: Run | Mouse: Look | E: Interact | 1: Dance | 2: Sit | L: Toggle LPK Panel
    </div>
    <div id="chatBubble"></div>
    
    <!-- LPK Loader Panel -->
    <div id="lpkPanel">
        <h3>üéÆ LPK Asset Loader</h3>
        <input type="file" id="fileInput" accept=".lpk" style="display: none;">
        <button id="loadLpkBtn">üìÅ Load LPK File</button>
        <button id="loadExistingBtn">üîÑ Load Existing LPK</button>
        <button id="toggleTerrainBtn" disabled>üèîÔ∏è Toggle Terrain</button>
        <button id="extractAssetsBtn" disabled>üì¶ Extract Assets</button>
        <div id="lpkStatus">Ready to load LPK files...</div>
        <div id="lpkInfo" style="font-size: 11px; margin-top: 10px;"></div>
    </div>
    
    <!-- Three.js CDN - Using unpkg CDN with specific version -->
    <script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
    <!-- JSZip for LPK file handling -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <script>
        // Social Hub Game - 3rd Person WebGL Game using Three.js
        // Modular structure for easy expansion
        
        class SocialHubGame {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.player = null;
                this.npcs = [];
                this.interactables = [];
                this.keys = {};
                this.mouse = { x: 0, y: 0 };
                this.gameState = {
                    coins: 0,
                    playerName: 'Visitor',
                    currentActivity: 'Walking'
                };
                this.clock = new THREE.Clock();
                this.raycaster = new THREE.Raycaster();
                this.mouseVector = new THREE.Vector2();
                
                // LPK Loader functionality
                this.lpkAssets = null;
                this.originalGround = null;
                this.lpkTerrain = null;
                this.lpkPanelVisible = true;
                
                this.init();
            }
            
            // Initialize the game
            init() {
                this.setupScene();
                this.setupLighting();
                this.setupPlayer();
                this.buildCity();
                this.createNPCs();
                this.setupUI();
                this.setupControls();
                this.setupLPKLoader();
                this.animate();
                
                document.getElementById('loading').style.display = 'none';
            }
            
            // Scene setup with Three.js
            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
                
                // Camera setup for 3rd person view
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                this.camera.position.set(0, 5, 10);
                
                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.setClearColor(0x87CEEB);
                document.body.appendChild(this.renderer.domElement);
                
                // Skybox
                const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
                const skyMaterial = new THREE.MeshBasicMaterial({
                    color: 0x87CEEB,
                    side: THREE.BackSide
                });
                const sky = new THREE.Mesh(skyGeometry, skyMaterial);
                this.scene.add(sky);
            }
            
            // Lighting setup for the city
            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                // Directional light (sun)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 500;
                directionalLight.shadow.camera.left = -100;
                directionalLight.shadow.camera.right = 100;
                directionalLight.shadow.camera.top = 100;
                directionalLight.shadow.camera.bottom = -100;
                this.scene.add(directionalLight);
            }
            
            // Player character setup
            setupPlayer() {
                // Player capsule (using cylinder as fallback for compatibility)
                let playerGeometry;
                try {
                    playerGeometry = new THREE.CapsuleGeometry(0.5, 1.5, 4, 8);
                } catch (e) {
                    // Fallback to cylinder if CapsuleGeometry not available
                    playerGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
                }
                const playerMaterial = new THREE.MeshLambertMaterial({ color: 0x4a90e2 });
                this.player = new THREE.Mesh(playerGeometry, playerMaterial);
                this.player.position.set(0, 1, 0);
                this.player.castShadow = true;
                this.scene.add(this.player);
                
                // Player properties
                this.player.userData = {
                    velocity: new THREE.Vector3(),
                    onGround: false,
                    canJump: true,
                    speed: 0.1,
                    runSpeed: 0.2
                };
                
                // Camera target for smooth following
                this.cameraTarget = new THREE.Object3D();
                this.cameraTarget.position.copy(this.player.position);
                this.scene.add(this.cameraTarget);
            }
            
            // City environment construction
            buildCity() {
                // Ground plane
                const groundGeometry = new THREE.PlaneGeometry(100, 100);
                const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                // Central plaza
                const plazaGeometry = new THREE.CircleGeometry(15, 32);
                const plazaMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const plaza = new THREE.Mesh(plazaGeometry, plazaMaterial);
                plaza.rotation.x = -Math.PI / 2;
                plaza.position.y = 0.01;
                plaza.receiveShadow = true;
                this.scene.add(plaza);
                
                // Buildings around the plaza
                const buildingPositions = [
                    { x: 20, z: 0, width: 8, height: 12, depth: 8, color: 0x8B4513 },
                    { x: -20, z: 0, width: 8, height: 10, depth: 8, color: 0x654321 },
                    { x: 0, z: 20, width: 6, height: 15, depth: 6, color: 0x2F4F4F },
                    { x: 0, z: -20, width: 10, height: 8, depth: 10, color: 0x696969 },
                    { x: 15, z: 15, width: 5, height: 6, depth: 5, color: 0x8B0000 },
                    { x: -15, z: -15, width: 7, height: 9, depth: 7, color: 0x228B22 }
                ];
                
                buildingPositions.forEach(pos => {
                    const buildingGeometry = new THREE.BoxGeometry(pos.width, pos.height, pos.depth);
                    const buildingMaterial = new THREE.MeshLambertMaterial({ color: pos.color });
                    const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                    building.position.set(pos.x, pos.height / 2, pos.z);
                    building.castShadow = true;
                    building.receiveShadow = true;
                    this.scene.add(building);
                });
                
                // Benches for interaction
                this.createBenches();
                
                // Coffee stand
                this.createCoffeeStand();
            }
            
            // Create interactive benches
            createBenches() {
                const benchPositions = [
                    { x: 8, z: 8 },
                    { x: -8, z: 8 },
                    { x: 8, z: -8 },
                    { x: -8, z: -8 }
                ];
                
                benchPositions.forEach(pos => {
                    const benchGeometry = new THREE.BoxGeometry(2, 0.5, 0.5);
                    const benchMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const bench = new THREE.Mesh(benchGeometry, benchMaterial);
                    bench.position.set(pos.x, 0.25, pos.z);
                    bench.userData = { type: 'bench', interactable: true };
                    this.interactables.push(bench);
                    this.scene.add(bench);
                });
            }
            
            // Create coffee stand
            createCoffeeStand() {
                const standGeometry = new THREE.BoxGeometry(2, 3, 1);
                const standMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const stand = new THREE.Mesh(standGeometry, standMaterial);
                stand.position.set(12, 1.5, 0);
                stand.userData = { type: 'coffee', interactable: true, cost: 5 };
                this.interactables.push(stand);
                this.scene.add(stand);
            }
            
            // Create wandering NPCs
            createNPCs() {
                const npcData = [
                    { name: 'Alice', color: 0xff6b6b, x: 5, z: 5 },
                    { name: 'Bob', color: 0x4ecdc4, x: -5, z: 5 },
                    { name: 'Charlie', color: 0x45b7d1, x: 5, z: -5 },
                    { name: 'Diana', color: 0xf9ca24, x: -5, z: -5 }
                ];
                
                npcData.forEach(data => {
                    const npc = this.createNPC(data);
                    this.npcs.push(npc);
                    this.scene.add(npc);
                });
            }
            
            // Create individual NPC
            createNPC(data) {
                // NPC capsule (using cylinder as fallback for compatibility)
                let npcGeometry;
                try {
                    npcGeometry = new THREE.CapsuleGeometry(0.4, 1.2, 4, 8);
                } catch (e) {
                    // Fallback to cylinder if CapsuleGeometry not available
                    npcGeometry = new THREE.CylinderGeometry(0.4, 0.4, 1.2, 8);
                }
                const npcMaterial = new THREE.MeshLambertMaterial({ color: data.color });
                const npc = new THREE.Mesh(npcGeometry, npcMaterial);
                npc.position.set(data.x, 1, data.z);
                npc.castShadow = true;
                
                // NPC properties
                npc.userData = {
                    name: data.name,
                    type: 'npc',
                    interactable: true,
                    waypoints: this.generateWaypoints(),
                    currentWaypoint: 0,
                    speed: 0.02,
                    lastMoveTime: 0,
                    messages: [
                        `Hi! I'm ${data.name}. Nice to meet you!`,
                        `The weather is lovely today, isn't it?`,
                        `Have you seen the new coffee stand?`,
                        `I love walking around the plaza!`
                    ]
                };
                
                return npc;
            }
            
            // Generate random waypoints for NPCs
            generateWaypoints() {
                const waypoints = [];
                for (let i = 0; i < 5; i++) {
                    waypoints.push({
                        x: (Math.random() - 0.5) * 30,
                        z: (Math.random() - 0.5) * 30
                    });
                }
                return waypoints;
            }
            
            // UI setup
            setupUI() {
                this.updateUI();
            }
            
            // Control setup
            setupControls() {
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                // Mouse controls
                document.addEventListener('mousemove', (e) => {
                    this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            // Main game loop
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const deltaTime = this.clock.getDelta();
                
                this.updatePlayer(deltaTime);
                this.updateNPCs(deltaTime);
                this.updateCamera();
                this.checkInteractions();
                this.updateUI();
                
                this.renderer.render(this.scene, this.camera);
            }
            
            // Player movement and physics
            updatePlayer(deltaTime) {
                const player = this.player;
                const userData = player.userData;
                
                // Movement input
                const moveVector = new THREE.Vector3();
                
                if (this.keys['KeyW']) moveVector.z -= 1;
                if (this.keys['KeyS']) moveVector.z += 1;
                if (this.keys['KeyA']) moveVector.x -= 1;
                if (this.keys['KeyD']) moveVector.x += 1;
                
                // Normalize movement
                if (moveVector.length() > 0) {
                    moveVector.normalize();
                    const speed = this.keys['ShiftLeft'] ? userData.runSpeed : userData.speed;
                    moveVector.multiplyScalar(speed);
                    
                    // Apply movement
                    player.position.add(moveVector);
                    userData.velocity.copy(moveVector);
                } else {
                    userData.velocity.multiplyScalar(0.9); // Friction
                }
                
                // Jumping
                if (this.keys['Space'] && userData.canJump) {
                    userData.velocity.y = 0.3;
                    userData.canJump = false;
                }
                
                // Simple gravity
                userData.velocity.y -= 0.01;
                player.position.y += userData.velocity.y;
                
                // Ground collision
                if (player.position.y <= 1) {
                    player.position.y = 1;
                    userData.velocity.y = 0;
                    userData.canJump = true;
                }
                
                // Keep player in bounds
                player.position.x = Math.max(-45, Math.min(45, player.position.x));
                player.position.z = Math.max(-45, Math.min(45, player.position.z));
                
                // Update activity
                if (moveVector.length() > 0) {
                    this.gameState.currentActivity = this.keys['ShiftLeft'] ? 'Running' : 'Walking';
                } else {
                    this.gameState.currentActivity = 'Idle';
                }
            }
            
            // NPC behavior update
            updateNPCs(deltaTime) {
                this.npcs.forEach(npc => {
                    const userData = npc.userData;
                    const currentTime = Date.now();
                    
                    if (currentTime - userData.lastMoveTime > 2000) { // Move every 2 seconds
                        const waypoint = userData.waypoints[userData.currentWaypoint];
                        const direction = new THREE.Vector3(
                            waypoint.x - npc.position.x,
                            0,
                            waypoint.z - npc.position.z
                        );
                        
                        if (direction.length() > 0.5) {
                            direction.normalize();
                            npc.position.add(direction.multiplyScalar(userData.speed));
                        } else {
                            userData.currentWaypoint = (userData.currentWaypoint + 1) % userData.waypoints.length;
                        }
                        
                        userData.lastMoveTime = currentTime;
                    }
                });
            }
            
            // Camera following system
            updateCamera() {
                const idealOffset = new THREE.Vector3(0, 5, 10);
                const idealPosition = this.player.position.clone().add(idealOffset);
                
                // Smooth camera movement
                this.camera.position.lerp(idealPosition, 0.1);
                this.camera.lookAt(this.player.position);
            }
            
            // Interaction system
            checkInteractions() {
                const playerPos = this.player.position;
                let nearestInteractable = null;
                let nearestDistance = Infinity;
                
                // Check NPCs
                this.npcs.forEach(npc => {
                    const distance = playerPos.distanceTo(npc.position);
                    if (distance < 3 && distance < nearestDistance) {
                        nearestInteractable = npc;
                        nearestDistance = distance;
                    }
                });
                
                // Check other interactables
                this.interactables.forEach(item => {
                    const distance = playerPos.distanceTo(item.position);
                    if (distance < 3 && distance < nearestDistance) {
                        nearestInteractable = item;
                        nearestDistance = distance;
                    }
                });
                
                // Show interaction prompt
                const interactionDiv = document.getElementById('interaction');
                if (nearestInteractable) {
                    interactionDiv.style.display = 'block';
                    interactionDiv.textContent = `Press E to ${this.getInteractionText(nearestInteractable)}`;
                    
                    // Handle E key press
                    if (this.keys['KeyE']) {
                        this.handleInteraction(nearestInteractable);
                        this.keys['KeyE'] = false; // Prevent spam
                    }
                } else {
                    interactionDiv.style.display = 'none';
                }
                
                // Handle activity keys
                if (this.keys['Digit1']) {
                    this.dance();
                    this.keys['Digit1'] = false;
                }
                
                if (this.keys['Digit2']) {
                    this.sit();
                    this.keys['Digit2'] = false;
                }
                
                if (this.keys['KeyL']) {
                    this.toggleLPKPanel();
                    this.keys['KeyL'] = false;
                }
            }
            
            // Get interaction text based on object type
            getInteractionText(obj) {
                switch (obj.userData.type) {
                    case 'npc': return `talk to ${obj.userData.name}`;
                    case 'bench': return 'sit down';
                    case 'coffee': return 'buy coffee';
                    default: return 'interact';
                }
            }
            
            // Handle interactions
            handleInteraction(obj) {
                switch (obj.userData.type) {
                    case 'npc':
                        this.talkToNPC(obj);
                        break;
                    case 'bench':
                        this.sitOnBench(obj);
                        break;
                    case 'coffee':
                        this.buyCoffee(obj);
                        break;
                }
            }
            
            // Talk to NPC
            talkToNPC(npc) {
                const messages = npc.userData.messages;
                const randomMessage = messages[Math.floor(Math.random() * messages.length)];
                this.showChatBubble(randomMessage, npc.position);
            }
            
            // Sit on bench
            sitOnBench(bench) {
                this.gameState.currentActivity = 'Sitting';
                this.showChatBubble('Ah, what a nice place to rest!', this.player.position);
            }
            
            // Buy coffee
            buyCoffee(stand) {
                if (this.gameState.coins >= stand.userData.cost) {
                    this.gameState.coins -= stand.userData.cost;
                    this.showChatBubble('Thanks for the coffee! ‚òï', this.player.position);
                } else {
                    this.showChatBubble('Not enough coins! Need 5 coins.', this.player.position);
                }
            }
            
            // Dance activity
            dance() {
                this.gameState.currentActivity = 'Dancing';
                this.showChatBubble('üíÉ Dancing! üíÉ', this.player.position);
                
                // Reset activity after 3 seconds
                setTimeout(() => {
                    this.gameState.currentActivity = 'Idle';
                }, 3000);
            }
            
            // Sit activity
            sit() {
                this.gameState.currentActivity = 'Sitting';
                this.showChatBubble('Taking a break...', this.player.position);
                
                // Reset activity after 2 seconds
                setTimeout(() => {
                    this.gameState.currentActivity = 'Idle';
                }, 2000);
            }
            
            // Show chat bubble
            showChatBubble(message, position) {
                const bubble = document.getElementById('chatBubble');
                bubble.textContent = message;
                bubble.style.display = 'block';
                
                // Position bubble above object
                const vector = position.clone();
                vector.project(this.camera);
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (vector.y * -0.5 + 0.5) * window.innerHeight - 50;
                
                bubble.style.left = x + 'px';
                bubble.style.top = y + 'px';
                
                // Hide after 3 seconds
                setTimeout(() => {
                    bubble.style.display = 'none';
                }, 3000);
            }
            
            // Update UI elements
            updateUI() {
                document.getElementById('playerName').textContent = this.gameState.playerName;
                document.getElementById('coins').textContent = this.gameState.coins;
                document.getElementById('activity').textContent = this.gameState.currentActivity;
            }
            
            // LPK Loader Setup
            setupLPKLoader() {
                const loadLpkBtn = document.getElementById('loadLpkBtn');
                const loadExistingBtn = document.getElementById('loadExistingBtn');
                const toggleTerrainBtn = document.getElementById('toggleTerrainBtn');
                const extractAssetsBtn = document.getElementById('extractAssetsBtn');
                const fileInput = document.getElementById('fileInput');
                
                // Load LPK file button
                loadLpkBtn.addEventListener('click', () => {
                    fileInput.click();
                });
                
                // File input change
                fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.loadLPKFile(e.target.files[0]);
                    }
                });
                
                // Load existing LPK button
                loadExistingBtn.addEventListener('click', () => {
                    this.loadExistingLPK();
                });
                
                // Toggle terrain button
                toggleTerrainBtn.addEventListener('click', () => {
                    this.toggleLPKTerrain();
                });
                
                // Extract assets button
                extractAssetsBtn.addEventListener('click', () => {
                    this.extractLPKAssets();
                });
            }
            
            // Load LPK file
            async loadLPKFile(file) {
                this.updateLPKStatus('Loading LPK file...', 'info');
                
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    await this.parseLPKFile(arrayBuffer, file.name);
                    
                } catch (error) {
                    console.error('Error loading LPK file:', error);
                    this.updateLPKStatus('Error loading LPK file: ' + error.message, 'error');
                }
            }
            
            // Load existing LPK from repository
            async loadExistingLPK() {
                this.updateLPKStatus('Loading existing LPK file...', 'info');
                
                try {
                    const response = await fetch('118c38f2-11ef-4566-be23-246731049822.lpk');
                    if (!response.ok) throw new Error('Failed to fetch LPK file');
                    
                    const arrayBuffer = await response.arrayBuffer();
                    await this.parseLPKFile(arrayBuffer, '118c38f2-11ef-4566-be23-246731049822.lpk');
                    
                } catch (error) {
                    console.error('Error loading existing LPK:', error);
                    this.updateLPKStatus('Error loading existing LPK: ' + error.message, 'error');
                }
            }
            
            // Parse LPK file
            async parseLPKFile(arrayBuffer, filename) {
                try {
                    // Extract LPK header and ZIP data
                    const header = new Uint8Array(arrayBuffer, 0, 8);
                    const headerHex = Array.from(header).map(b => b.toString(16).padStart(2, '0')).join('');
                    
                    this.updateLPKStatus('Parsing LPK structure...', 'info');
                    
                    // Extract ZIP portion (skip 8-byte header)
                    const zipData = arrayBuffer.slice(8);
                    
                    // Load ZIP with JSZip
                    const zip = new JSZip();
                    const zipFile = await zip.loadAsync(zipData);
                    
                    const assets = {
                        filename: filename,
                        header: headerHex,
                        files: {},
                        fileCount: 0,
                        totalSize: arrayBuffer.byteLength
                    };
                    
                    // Analyze ZIP contents
                    for (const [filename, file] of Object.entries(zipFile.files)) {
                        if (file.dir) continue;
                        
                        assets.files[filename] = {
                            name: filename,
                            compressedSize: file._data ? file._data.compressedSize : 0,
                            uncompressedSize: file._data ? file._data.uncompressedSize : 0,
                            encrypted: true // Assume encrypted for now
                        };
                        assets.fileCount++;
                    }
                    
                    this.lpkAssets = assets;
                    this.updateLPKDisplay();
                    this.updateLPKStatus('LPK file loaded successfully!', 'success');
                    
                    // Enable buttons
                    document.getElementById('toggleTerrainBtn').disabled = false;
                    document.getElementById('extractAssetsBtn').disabled = false;
                    
                    // Create demo terrain
                    this.createDemoTerrain();
                    
                } catch (error) {
                    throw new Error('Failed to parse LPK file: ' + error.message);
                }
            }
            
            // Update LPK display
            updateLPKDisplay() {
                const lpkInfo = document.getElementById('lpkInfo');
                if (!this.lpkAssets) {
                    lpkInfo.innerHTML = '';
                    return;
                }
                
                const assets = this.lpkAssets;
                lpkInfo.innerHTML = `
                    <strong>üìÅ ${assets.filename}</strong><br>
                    Size: ${(assets.totalSize / 1024).toFixed(1)} KB<br>
                    Header: ${assets.header}<br>
                    Files: ${assets.fileCount}<br>
                    ${Object.keys(assets.files).map(name => 
                        `‚Ä¢ ${name} (${(assets.files[name].uncompressedSize / 1024).toFixed(1)} KB)`
                    ).join('<br>')}
                `;
            }
            
            // Update LPK status
            updateLPKStatus(message, type) {
                const statusDiv = document.getElementById('lpkStatus');
                statusDiv.textContent = message;
                statusDiv.className = `status-${type}`;
            }
            
            // Create demo terrain from LPK data
            createDemoTerrain() {
                if (this.lpkTerrain) return; // Already created
                
                // Create a more interesting terrain to show LPK integration
                const geometry = new THREE.PlaneGeometry(80, 80, 32, 32);
                const vertices = geometry.attributes.position.array;
                
                // Add some height variation to simulate terrain from LPK data
                for (let i = 0; i < vertices.length; i += 3) {
                    const x = vertices[i];
                    const z = vertices[i + 2];
                    // Create hills and valleys
                    vertices[i + 1] = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 3 + 
                                     Math.sin(x * 0.05) * 2 + 
                                     Math.random() * 0.5;
                }
                
                geometry.attributes.position.needsUpdate = true;
                geometry.computeVertexNormals();
                
                const material = new THREE.MeshLambertMaterial({ 
                    color: 0x4a7c59,
                    wireframe: false
                });
                
                this.lpkTerrain = new THREE.Mesh(geometry, material);
                this.lpkTerrain.rotation.x = -Math.PI / 2;
                this.lpkTerrain.position.y = -1;
                this.lpkTerrain.receiveShadow = true;
                this.lpkTerrain.visible = false; // Start hidden
                
                this.scene.add(this.lpkTerrain);
                
                // Store reference to original ground
                if (!this.originalGround) {
                    this.scene.traverse((child) => {
                        if (child.isMesh && child.geometry instanceof THREE.PlaneGeometry && 
                            child.position.y < 0.1 && child.rotation.x < -1) {
                            this.originalGround = child;
                        }
                    });
                }
            }
            
            // Toggle LPK terrain
            toggleLPKTerrain() {
                if (!this.lpkTerrain) {
                    this.updateLPKStatus('No terrain available', 'error');
                    return;
                }
                
                const isVisible = this.lpkTerrain.visible;
                this.lpkTerrain.visible = !isVisible;
                
                if (this.originalGround) {
                    this.originalGround.visible = isVisible;
                }
                
                const btn = document.getElementById('toggleTerrainBtn');
                btn.textContent = this.lpkTerrain.visible ? 'üèîÔ∏è Hide Terrain' : 'üèîÔ∏è Show Terrain';
                
                this.updateLPKStatus(
                    this.lpkTerrain.visible ? 'LPK terrain enabled' : 'Original terrain restored', 
                    'success'
                );
                
                this.showChatBubble(
                    this.lpkTerrain.visible ? 'LPK terrain loaded!' : 'Back to original terrain', 
                    this.player.position
                );
            }
            
            // Extract LPK assets
            extractLPKAssets() {
                if (!this.lpkAssets) {
                    this.updateLPKStatus('No LPK file loaded', 'error');
                    return;
                }
                
                const exportData = {
                    timestamp: new Date().toISOString(),
                    lpkFile: this.lpkAssets.filename,
                    analysis: this.lpkAssets,
                    note: 'Files are encrypted - this is the structural analysis only'
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], {
                    type: 'application/json'
                });
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'lpk-analysis.json';
                a.click();
                URL.revokeObjectURL(url);
                
                this.updateLPKStatus('Analysis exported successfully!', 'success');
                this.showChatBubble('LPK analysis exported! üìÅ', this.player.position);
            }
            
            // Toggle LPK panel visibility
            toggleLPKPanel() {
                const panel = document.getElementById('lpkPanel');
                this.lpkPanelVisible = !this.lpkPanelVisible;
                panel.style.display = this.lpkPanelVisible ? 'block' : 'none';
                
                this.showChatBubble(
                    this.lpkPanelVisible ? 'LPK Panel opened' : 'LPK Panel closed', 
                    this.player.position
                );
            }
        }
        
        // Start the game when page loads and Three.js is available
        function initGame() {
            if (typeof THREE !== 'undefined') {
                new SocialHubGame();
            } else {
                console.log('Waiting for Three.js to load...');
                setTimeout(initGame, 100);
            }
        }
        
        window.addEventListener('load', initGame);
    </script>
</body>
</html>